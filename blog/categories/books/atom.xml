<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: books | Hack hack hack...]]></title>
  <link href="http://adamjonas.com/blog/categories/books/atom.xml" rel="self"/>
  <link href="http://adamjonas.com/"/>
  <updated>2016-04-06T14:18:07-04:00</updated>
  <id>http://adamjonas.com/</id>
  <author>
    <name><![CDATA[Adam Jonas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gang of Four - Observer and Mediator Pattern]]></title>
    <link href="http://adamjonas.com/blog/gang-of-four-observer-and-mediator-pattern/"/>
    <updated>2016-03-16T13:32:00-04:00</updated>
    <id>http://adamjonas.com/blog/gang-of-four-observer-and-mediator-pattern</id>
    <content type="html"><![CDATA[<h2>Observer</h2>

<ul>
<li>subject is a logical place to keep track of the collection of the observers

<ul>
<li>the upside is the observers needing to check with the subject via something like long-polling versus the subject notifying the owners</li>
</ul>
</li>
<li>ActiveRecord before_actions and after_actions are a ruby implementation of the observer pattern</li>
<li>How does JS does this?

<ul>
<li>functions are first class object, easy to pass around</li>
</ul>
</li>
</ul>


<h2>Mediator</h2>

<ul>
<li>what's the difference between mediator and observer

<ul>
<li>Define an object that encapsulates how a set of objects interact.</li>
<li>Mediator is a little more specific, it avoids having classes communicate directly but instead through a mediator. This helps the Single Responsibility principle by allowing communication to be offloaded to a class that just handles that.</li>
</ul>
</li>
<li>replaces many to many interactions with one to many interactions.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gang of Four: Proxy and adapter pattern]]></title>
    <link href="http://adamjonas.com/blog/proxy-and-adapter-pattern/"/>
    <updated>2016-03-09T13:10:00-05:00</updated>
    <id>http://adamjonas.com/blog/proxy-and-adapter-pattern</id>
    <content type="html"><![CDATA[<h2>Proxy</h2>

<ul>
<li>reverse proxies</li>
<li>virtual proxy: creates expensive objects on demand. the worker box maybe?

<ul>
<li>infinite scroll or pagination (these objects exist in Octokit, where there are objects as placeholders but it hasn't acutally fetched the data)</li>
<li>memoization example in the ruby boook</li>
<li><a href="http://edgeapi.rubyonrails.org/classes/ActiveRecord/Associations/CollectionProxy.html">collection proxy</a></li>
</ul>
</li>
</ul>


<h2>Adapter (aka wrapper)</h2>

<ul>
<li>Fog: cloud storage</li>
<li>ActiveRecord</li>
<li>OctokitWrapper is more of a decorator because it adds additional implementation on top of Octokit</li>
<li>Gateway pattern is an adapter specifically created to talk to external services</li>
<li>HierarchyBuilder is the adapter</li>
<li>The key difference between bridge and apater lies in their intents.

<ul>
<li>Adapter focuses on resolving incompatibilities between two existing interfaces. Bridge, on the other hand, bridges an abstraction and its (potentially numerous) implementations.</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gang of Four: Builder pattern and Singletons]]></title>
    <link href="http://adamjonas.com/blog/gang-of-four-builder-pattern-and-singletons/"/>
    <updated>2016-03-02T12:07:00-05:00</updated>
    <id>http://adamjonas.com/blog/gang-of-four-builder-pattern-and-singletons</id>
    <content type="html"><![CDATA[<h2>Builder</h2>

<ul>
<li>Concrete builders: <code>html to markdown</code> and <code>html to json</code>?</li>
<li>Could we think of a complex cart like this? Like line items of a educational program might compose a composite object by the cart which is the director.

<ul>
<li>doesn't quite match up with subbing in different builders</li>
</ul>
</li>
<li>like strategy pattern, but the way it differs is that it creates a composite object at the end</li>
<li>but this book is more about the abstract factory, the way this differs is that it the director gives you finer control of the order.</li>
<li><p>separating out <strong>how</strong> the object is built</p></li>
<li><p>e.g. Creating enrollments with one time purchases vs recurring subscriptions</p>

<ul>
<li>client == browser</li>
<li>director == model ShoppingCart</li>
<li>builder1 == JobGuaranteeSubscription</li>
<li>builder2 == NonJobGuaranteeSubscription</li>
<li><p>result == subscription</p></li>
<li><p>Build part: slack group, google group, batch</p></li>
</ul>
</li>
</ul>


<h2>Singleton</h2>

<ul>
<li>there is only one instance and so if another part of the code changes it, then you will have shot yourself in the foot</li>
<li>publishers, which are all singletons, don't need more than one, but they could have been classes instead</li>
<li>dependency injection makes tests way easier</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gang of Four: Decorator and Composition]]></title>
    <link href="http://adamjonas.com/blog/gang-of-four-decorator-and-composition/"/>
    <updated>2016-02-17T13:56:00-05:00</updated>
    <id>http://adamjonas.com/blog/gang-of-four-decorator-and-composition</id>
    <content type="html"><![CDATA[<h2>Decorator</h2>

<ul>
<li>OOCSS -> does that fit the pattern?</li>
<li>"Changing the skin of an object versus changing its guts"</li>
</ul>


<h2>Composite</h2>

<ul>
<li>componenet: parent node</li>
<li>composite: has children</li>
<li>leaf: has no children</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gang of Four Chap 1]]></title>
    <link href="http://adamjonas.com/blog/gang-of-four-chap-1/"/>
    <updated>2016-02-03T13:41:00-05:00</updated>
    <id>http://adamjonas.com/blog/gang-of-four-chap-1</id>
    <content type="html"><![CDATA[<h2>Polymorphism vs duck typing</h2>

<ul>
<li>from the gospel of <a href="http://stackoverflow.com/a/11502482/1496757">stackoverflow</a> and <a href="http://programmers.stackexchange.com/a/121781">stackexchange</a> and a <a href="https://gist.github.com/46bit/4366791">gist</a></li>
</ul>


<p>  ### Polymorphism</p>

<pre><code>- often hear in the context of subclasses
</code></pre>

<p>  ### Duck typing</p>

<pre><code>- usually hear in the context of mixins
- an interface that can interact without having to know what that object is
</code></pre>

<ul>
<li>class inheritance versus interface inheritance</li>
</ul>


<h2>Composition vs class inheritance</h2>

<ul>
<li>Rule of thumb: when behavior spans classes use composition and when limited to derivations of classes then use subclassing</li>
<li></li>
</ul>


<h2>Run time versus compile time</h2>

<h2>Program to an interface not an implementation</h2>

<ul>
<li>interface is the behavior</li>
</ul>

]]></content>
  </entry>
  
</feed>

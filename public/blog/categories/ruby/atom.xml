<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Documenting all this...]]></title>
  <link href="http://ajonas.herokuapp.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://ajonas.herokuapp.com/"/>
  <updated>2012-10-06T15:23:20-04:00</updated>
  <id>http://ajonas.herokuapp.com/</id>
  <author>
    <name><![CDATA[Adam Jonas]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Assignment1]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/10/06/assignment1/"/>
    <updated>2012-10-06T14:54:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/10/06/assignment1</id>
    <content type="html"><![CDATA[<p>```ruby Quiz1.rb</p>

<h1>Write a program that tells you the following:</h1>

<p>#</p>

<h1>Hours in a year. How many hours are in a year? - 6pts</h1>

<h1>Minutes in a decade. How many minutes are in a decade? - 6pts</h1>

<h1>Your age in seconds. How many seconds old are you? - 6pts</h1>

<p>#</p>

<h1>Define at least the following methods to accomplish these tasks:</h1>

<p>#</p>

<h1>seconds_in_minutes(1) #=> 60 - 3pts</h1>

<h1>minutes_in_hours(1) #=> 60 - 3pts</h1>

<h1>hours_in_days(1) #=> 24 - 3pts</h1>

<h1>days_in_weeks(1) #=> 7 - 3pts</h1>

<h1>weeks_in_years(1) #=> 52 - 3pts</h1>

<p>#</p>

<h1>If I am 1,111 million seconds old, how old am I?</h1>

<h1>Define an age_from_seconds method - 7pts</h1>

<p>def seconds_in_minutes(minutes)</p>

<pre><code>minutes*60
</code></pre>

<p>end</p>

<p>def minutes_in_hours(hours)</p>

<pre><code>hours*60
</code></pre>

<p>end</p>

<p>def hours_in_days(day)</p>

<pre><code>day*24
</code></pre>

<p>end</p>

<p>def days_in_weeks(weeks)</p>

<pre><code>weeks*7
</code></pre>

<p>end</p>

<p>def weeks_in_years(years)</p>

<pre><code>years*52
</code></pre>

<p>end</p>

<p>def hours_in_years(years)</p>

<pre><code>years*weeks_in_years(1)*days_in_weeks(1)*hours_in_days(1)
</code></pre>

<p>end</p>

<p>def minutes_in_a_decade(decades)</p>

<pre><code>decades*hours_in_years(10)*minutes_in_hours(1)
</code></pre>

<p>end</p>

<p>def age_in_seconds(years)</p>

<pre><code>hours_in_years(years)*minutes_in_hours(1)*seconds_in_minutes(1)
</code></pre>

<p>end</p>

<p>def age_from_seconds(seconds)</p>

<pre><code>minutes = seconds/60 
hours = minutes/60
days = hours/24
years = days/365
years.to_f
</code></pre>

<p>end</p>

<p>puts "There are #{seconds_in_minutes(1)} seconds in minutes"
puts "There are #{minutes_in_hours(1)} minutes in hours"
puts "There are #{hours_in_days(1)} hours in a day"
puts "There are #{days_in_weeks(1)} days in a week"
puts "There are #{weeks_in_years(1)} weeks in a year"
puts "There are #{hours_in_years(1)} hours in a year"
puts "There are #{minutes_in_a_decade(1)} minutes in a decade"
puts "You are #{age_in_seconds(31)} seconds old"
puts "You are #{age_from_seconds(1111000000)} years old"
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FISday3]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/10/05/fisday3/"/>
    <updated>2012-10-05T16:48:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/10/05/fisday3</id>
    <content type="html"><![CDATA[<p>Programs are:</p>

<p><em>idealized components</em>... not bound by degradation of use.</p>

<p><em>infinite complexity</em>... because nothing is stopping us from building it.</p>

<p><em>Method signature</em> is the first line of the method (e.g. def method_name(*arg))</p>

<p><em>Parameters</em> are the adverbs. Parameters allow us to make a method dynamic.</p>

<p>To the computer, there is no difference between a local variable and a method.</p>

<p>'==' => value equality
'===' => object equality</p>

<p>A computationally efficient language will compile down faster than</p>

<p><em>lazy evaluation</em>- the program will stop as soon as an if or elsif is satisfied. It won't execute any more statements.</p>

<p><a href="http://www.bartleby.com/103/6.html">Ode</a> by Arthur O'Shaughnessy</p>

<p>?? Are there languages with more syntactic sugar than ruby?
?? is it really not possible to write a program in SQL
Does <a href="http://www.simple-talk.com/blogs/2005/12/30/a-sql-game/">this</a> qualify as a program?
<a href="http://www.red-gate.com/downloads/CreateTheMazeGame.txt">SQL code:</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Standard Library]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/09/18/ruby-standard-library/"/>
    <updated>2012-09-18T13:59:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/09/18/ruby-standard-library</id>
    <content type="html"><![CDATA[<h3><a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/fileutils/rdoc/FileUtils.html">FileUtils</a></h3>

<p>The functions mostly involved changing dir, moving, removing, and copying files.</p>

<p>Going to give us different options for working with dir entries and files in the file system.</p>

<p>easy to work with in IRB</p>

<h3>Methods</h3>

<p>.cmp will tell you if two files have the same content
.touch creates a file if it doesn't exist
.cp copy contents to another file</p>

<h3><a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/logger/rdoc/Logger.html">Logger:</a></h3>

<h3>URIs</h3>

<p>URI stands for "Uniform Resource Identifier." The URI module can be used to parse and manipulate URIs in your Ruby programs.</p>

<p>```</p>

<blockquote><p>require 'uri'
 => true
require 'open-uri'
 => true
url = URI.parse('http://teamtreehouse.com/')
 => #&lt;URI::HTTP:0x007f9b728dfda0 URL:http://teamtreehouse.com/>
puts url.inspect</p>

<h1>&lt;URI::HTTP:0x007f9b728dfda0 URL:http://teamtreehouse.com/></h1>

<p> => nil
puts url.hostanme
NoMethodError: undefined method `hostanme' for #&lt;URI::HTTP:0x007f9b728dfda0 URL:http://teamtreehouse.com/></p>

<pre><code>from (irb):10
from /Users/Ajonas/.rvm/rubies/ruby-1.9.3-p194/bin/irb:16:in `&lt;main&gt;'
</code></pre>

<p>puts url.hostname
teamtreehouse.com
 => nil
puts url.path
/
 => nil
puts URI.split('http://teamtreehouse.com').inspect
["http", nil, "teamtreehouse.com", nil, nil, "", nil, nil, nil]
 => nil
google = open('http://google.com').read
=> this outputs the html of the google homepage...
```</p></blockquote>

<h3>Benchmark Module</h3>

<p>Provides methods to report the time used that the program takes to execute...</p>

<p>```ruby Benchmarking symbols vs strings
require 'benchmark'</p>

<p>repetitions = 1000000</p>

<p>Benchmark.bm(7) do |x|</p>

<pre><code>x.report "String" do
    repetitions.times do
        options = { 'hello' =&gt; 'world' }
    end
end

x.report 'Symbol' do
    repetitions.times do
        options = { hello: :world }
    end
end
</code></pre>

<p>end
```</p>

<h3>OptParse Library</h3>

<p>```ruby
require 'ostruct'
require 'optparse'
require 'open-uri'</p>

<p>class MyParser</p>

<pre><code>def self.parse(args)
    options = OpenStruct.new
    opts = OptionParser.new do |opts|
        opts.banner = "Usage: url"

        opts.on('-u', '--url URL', 'Fetches the given url') do |url|
            options.url = url
        end
    end

    begin
        opts.parse!(args)
    rescue Exception =&gt; e
        puts "Exceptions encountered: #{e}"
        puts opts
        exit 1
    end

    options
end
</code></pre>

<p>end</p>

<p>options = MyParser.parse(ARGV)</p>

<p>if options.url</p>

<pre><code>puts open(options.url).read
</code></pre>

<p>end
```</p>

<h3>Observable Library</h3>

<p>The Observable module allows you to easily implement the observer pattern in your classes. The observer pattern specifies that an object maintains a list of its dependents, called observers, and notifies them automatically of any state changes.</p>

<p>You could put this behavior in the classes themselves, but by putting them in an observer class it keeps the classes clean.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struct]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/09/10/struct/"/>
    <updated>2012-09-10T12:33:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/09/10/struct</id>
    <content type="html"><![CDATA[<p>```ruby Struct
Struct.new("Flatiron", :name, :location)</p>

<p>flatiron = Struct::Flatiron.new
flatiron.name "Flatiron"
flatiron.location = "33 West 26th st"
```</p>

<p><code>ruby Here is another way to do it...
School = Struct.new(:name, :location)
flatiron = School.new("flatiron", "33 west 26th")
</code>
```ruby we can also define a method in the struct
School = Struct.new(:name, :location)</p>

<pre><code>def travel
    puts "going to #{location} location..."
end
</code></pre>

<p>end</p>

<p>flatiron = School.new("flatiron", "33 west 26th")</p>

<p>flatiron.travel
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Bits]]></title>
    <link href="http://ajonas.herokuapp.com/blog/2012/09/06/ruby-bits/"/>
    <updated>2012-09-06T15:33:00-04:00</updated>
    <id>http://ajonas.herokuapp.com/blog/2012/09/06/ruby-bits</id>
    <content type="html"><![CDATA[<p>||= Assigns if there is not existing value. Otherwise, the previous assigment will override it.
Good way to set defaults if you need them</p>

<p>```ruby Refactoring using ||=
options[:country] = 'us' if options[:country].nil?</p>

<h1>can refactor as</h1>

<p>options[:country] ||= 'us'
```</p>

<p>```ruby Case statement e.g.
def search(games, search_term)
  search_index = case games.find_index(search_term)</p>

<pre><code>  when search_index
     "Game #{search_term} found: #{games[search_index]} at index #{search_index}."
   else
    "Game #{search_term} not found."
  end
</code></pre>

<p>end
games = ["Super Mario Bros.", "Contra", "Metroid", "Mega Man 2"]
puts search(games, "Contra")
```</p>

<p>```ruby Options
def new_game(name, options= {})
  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
game = new_game("Street Figher II",
 year: 1992,
 system: "SNES"
 )
```</p>

<p>rindex- Returns the index of the last occurrence of the given substring or pattern (regexp) in str. Returns nil if not found. If the second parameter is present, it specifies the position in the string to end the searchâ€”characters beyond this point will not be considered.</p>

<p>private methods: all private methods are not accessible for outside objects</p>

<p>```ruby Raising Exceptions
class InvalidGameError &lt; StandardError; end
def new_game(name, options={})
  raise InvalidGameError if name.nil?
  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
begin
  game = new_game(nil)
rescue InvalidGameError => e
  puts "There was a problem creating your new game: #{e.message}"
end
```</p>

<p>```ruby splat arguments
def describe_favorites(*games)
  for game in games</p>

<pre><code>puts "Favorite Game: #{game}"
</code></pre>

<p>  end<br/>
end
describe_favorites('Mario', 'Contra', 'Metroid')
```</p>

<p>```ruby Classes
class Game
  def initialize(name, options={})</p>

<pre><code>@name = name
@system = options[:system]
@year = options[:year]
</code></pre>

<p>  end
end
```</p>

<h3>Encapsulation</h3>

<p>Passing around data and numbers breaks encapsulation
If all you are passing around is data- then an options hash should suffice</p>

<h3>Private / Protected Methods</h3>

<p>Private methods in Ruby cannot be called with an explicit receiver.
```ruby Private
def up_vote(friend)</p>

<h1>in this case, bump karma is private</h1>

<pre><code>bump_karma
#below will error out
friend.bump_karma
</code></pre>

<p>end
```</p>

<p>Protected methods in Ruby CAN be called with an explicit receiver, but not outside the class.
```ruby Protected
def up_vote(friend)</p>

<h1>in this case, bump karma is private</h1>

<pre><code>bump_karma
#below will error out
friend.bump_karma
</code></pre>

<p>end
```</p>

<h3>Inheritance / Super</h3>

<p>A way to DRY up duplication is to use inheritance ot inherit behavior for two classes</p>

<p>Super looks for definitions in the parent class and applies it in the child class</p>

<h3>Active Support</h3>

<p>```ruby
def anniversary(game, years)
  game[:release].advance(years: years)
end</p>

<p>game = {
  name: 'Contra',
  release: DateTime.new(1987, 2, 20, 0, 0, 0)
}
puts anniversary(game, 20)
```</p>

<p>```ruby difference between hashes</p>

<h1>Using ActiveSupport, return the difference between Mario's favorite games and Luigis's favorite games by implementing the difference_between method.</h1>

<p>def difference_between(player1, player2)
  player1.diff(player2)
end
```</p>

<p>when you include something. it is included in the ancestor's class.</p>

<h3>Namespacing</h3>

<p>putting functions in a module will prevent namespacing conflicts
a common pattern is to 'include' the module inside of the class... this will expose the module methods as instances methods in the object -- which means the methods will have access to the object's internal properties.</p>

<p>when use mixin versus classical class inheritance.
A class can only have one super class
inheritance suggests specialization</p>

<p>the extends keyword included as the class methods</p>

<p>use extend to expose class methods as class methods
use include to expose class methods as instance methods</p>

<p>if you call extend on an object, then it exposes the methods as instance methods on an object</p>

<p>```ruby object extend
game = Game.new("Contra")</p>

<h1>extend the Playable module for the specific game object</h1>

<h1>the module is not available to other objects in that class</h1>

<p>game.extend(Playable)
game.play
```</p>

<p>method hooks allows you to both include and extend modules</p>

<p>```ruby
module LibraryUtils</p>

<p>  def add_game(game)
  end</p>

<p>  def remove_game(game)
  end</p>

<h1>this extends the ClassMethods so that it doesn't need to be called below</h1>

<p>  def self.included(base)</p>

<pre><code>base.extend(ClassMethods)
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>def search_by_game_name(name)
end
</code></pre>

<p>  end
end</p>

<p>class AtariLibrary
  include LibraryUtils
  #see-- no extend but still includes the class methods module...
end
```</p>

<h3>Active Support Concern</h3>

<p>this allows us to use the include and extend calls without making it so ugly.</p>

<p>```ruby ActiveSupport Concern
require 'active_support/concern'</p>

<p>module LibraryUtils</p>

<h1>this ensures that the dependencies are properly resolved...</h1>

<p>  extend ActiveSupport::Concern</p>

<p>  def add_game(game)
  end</p>

<p>  def remove_game(game)
  end</p>

<p>  module ClassMethods</p>

<pre><code>def search_by_game_name(name)
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby ActiveSupport Concern
module LibraryLoader</p>

<p>  module ClassMethods</p>

<pre><code>def load_game_list
end
</code></pre>

<p>  end
end</p>

<p>module LibraryUtils</p>

<p>  extend ActiveSupport::Concern</p>

<p>  #included block below is much cleaner
  included do</p>

<pre><code>load_game_list
</code></pre>

<p>  end
end</p>

<p>class AtariLibrary
  include LibraryUtils
end
```
Some more in depth reading to understand this better...
<a href="http://yehudakatz.com/2009/11/12/better-ruby-idioms/">here is an explanation from yehuda katz</a></p>

<p><a href="http://www.fakingfantastic.com/2010/09/20/concerning-yourself-with-active-support-concern/">Concerning Yourself with ActiveSupport::Concern</a></p>

<p>From 2010- <a href="http://www.strictlyuntyped.com/2010/05/tweaking-on-rails-30-2.html">Tweaking on Rails 3.0: #2 ActiveSupport::Concern</a></p>

<h3>Blocks</h3>

<p>```ruby Yields
class Library
  attr_accessor :games</p>

<p>  def initialize(games = [])</p>

<pre><code>self.games = games
</code></pre>

<p>  end</p>

<p>  def each_on_system(system)</p>

<pre><code>games.each do |game| 
#'yield game'yields the game object
  yield game if game.system == system
end
</code></pre>

<p>  end
end
```</p>

<p>```ruby Yields
  def list</p>

<pre><code>games.each do |game|
  puts yield game
end
</code></pre>

<p>  end
```</p>

<p>```ruby
class Game
  attr_accessor :name, :year, :system
  attr_reader :created_at</p>

<p>  def initialize(name, options={})</p>

<pre><code>self.name = name
self.year = options[:year]
self.system = options[:system]
@created_at = Time.now
</code></pre>

<p>  end</p>

<p>  def play</p>

<pre><code>emulate do |emulator|
  emulator.play(self)
end
</code></pre>

<p>  end</p>

<p>  def screenshot</p>

<pre><code>emulate do |emulator|
  emulator.start(self) 
  emulator.screenshot
end
</code></pre>

<p>  end</p>

<p>private</p>

<p>def emulate
  begin
  emulator = Emulator.new(system)
  yield emulator</p>

<pre><code>rescue Exception =&gt; e
  puts "Emulator failed: #{e}"
</code></pre>

<p>  end
end
end
```</p>
]]></content>
  </entry>
  
</feed>
